// Code generated by protoc-gen-go-cybozu-validate. DO NOT EDIT.
package examples

import (
	errors "errors"
	fmt "fmt"
	validate "github.com/cybozu/protobuf/cybozu/validate"
	precis "golang.org/x/text/secure/precis"
	norm "golang.org/x/text/unicode/norm"
	mail "net/mail"
	url "net/url"
	regexp "regexp"
	strings "strings"
	utf8 "unicode/utf8"
)

func (x *Scalars) Validate() error {
	var el []error
	if v := x.Float; true {
		if v >= 3.2 {
			el = append(el, fmt.Errorf("invalid value for float of examples.Scalars: %v", v))
		}
	}
	if v := x.Double; true {
		if v <= 3.2 {
			el = append(el, fmt.Errorf("invalid value for double of examples.Scalars: %v", v))
		}
	}
	if v := x.Int32; true {
		if v > -3 {
			el = append(el, fmt.Errorf("invalid value for int32 of examples.Scalars: %v", v))
		}
	}
	if v := x.Int64; true {
		if v < 1 {
			el = append(el, fmt.Errorf("invalid value for int64 of examples.Scalars: %v", v))
		}
	}
	if v := x.Uint32; true {
		if v <= 0x1 || v >= 0x5 {
			el = append(el, fmt.Errorf("invalid value for uint32 of examples.Scalars: %v", v))
		}
	}
	if v := x.Uint64; true {
		if v < 0x1 || v > 0x5 {
			el = append(el, fmt.Errorf("invalid value for uint64 of examples.Scalars: %v", v))
		}
	}
	if v := x.Sint32; true {
		if v <= 1 || v >= 5 {
			el = append(el, fmt.Errorf("invalid value for sint32 of examples.Scalars: %v", v))
		}
	}
	if v := x.Sint64; true {
		if v < 1 || v > 5 {
			el = append(el, fmt.Errorf("invalid value for sint64 of examples.Scalars: %v", v))
		}
	}
	if v := x.Fixed32; true {
		if v <= 0x1 || v >= 0x5 {
			el = append(el, fmt.Errorf("invalid value for fixed32 of examples.Scalars: %v", v))
		}
	}
	if v := x.Fixed64; true {
		if v <= 0x1 || v >= 0x5 {
			el = append(el, fmt.Errorf("invalid value for fixed64 of examples.Scalars: %v", v))
		}
	}
	if v := x.Sfixed32; true {
		if v <= 1 || v >= 5 {
			el = append(el, fmt.Errorf("invalid value for sfixed32 of examples.Scalars: %v", v))
		}
	}
	if v := x.Sfixed64; true {
		if v <= 1 || v >= 5 {
			el = append(el, fmt.Errorf("invalid value for sfixed64 of examples.Scalars: %v", v))
		}
	}
	if v := x.String_; true {
		v = norm.NFC.String(v)
		if v != "" {
			if vlen := utf8.RuneCountInString(v); vlen < 0x3 {
				el = append(el, fmt.Errorf("invalid value for string of examples.Scalars: %v", v))
			}
		}
		x.String_ = v
	}
	if v := x.Bytes; true {
		if vlen := len(v); vlen > 0xa {
			el = append(el, fmt.Errorf("invalid value for bytes of examples.Scalars: %v", v))
		}
	}

	if err := validate.CallValidateCustom(x); err != nil {
		if v, ok := err.(interface{ Unwrap() []error }); ok {
			el = append(el, v.Unwrap()...)
		} else {
			el = append(el, err)
		}
	}

	if len(el) == 0 {
		return nil
	}
	return errors.Join(el...)
}

func (x *OptionalScalars) Validate() error {
	var el []error
	if x.Float != nil {
		v := *x.Float
		if v >= 3.2 {
			el = append(el, fmt.Errorf("invalid value for float of examples.OptionalScalars: %v", v))
		}
	}
	if x.Double != nil {
		v := *x.Double
		if v <= 3.2 {
			el = append(el, fmt.Errorf("invalid value for double of examples.OptionalScalars: %v", v))
		}
	}
	if x.Int32 != nil {
		v := *x.Int32
		if v > -3 {
			el = append(el, fmt.Errorf("invalid value for int32 of examples.OptionalScalars: %v", v))
		}
	}
	if x.Int64 != nil {
		v := *x.Int64
		if v < 1 {
			el = append(el, fmt.Errorf("invalid value for int64 of examples.OptionalScalars: %v", v))
		}
	}
	if x.Uint32 != nil {
		v := *x.Uint32
		if v <= 0x1 || v >= 0x5 {
			el = append(el, fmt.Errorf("invalid value for uint32 of examples.OptionalScalars: %v", v))
		}
	}
	if x.Uint64 != nil {
		v := *x.Uint64
		if v < 0x1 || v > 0x5 {
			el = append(el, fmt.Errorf("invalid value for uint64 of examples.OptionalScalars: %v", v))
		}
	}
	if x.Sint32 != nil {
		v := *x.Sint32
		if v <= 1 || v >= 5 {
			el = append(el, fmt.Errorf("invalid value for sint32 of examples.OptionalScalars: %v", v))
		}
	}
	if x.Sint64 != nil {
		v := *x.Sint64
		if v < 1 || v > 5 {
			el = append(el, fmt.Errorf("invalid value for sint64 of examples.OptionalScalars: %v", v))
		}
	}
	if x.Fixed32 != nil {
		v := *x.Fixed32
		if v <= 0x1 || v >= 0x5 {
			el = append(el, fmt.Errorf("invalid value for fixed32 of examples.OptionalScalars: %v", v))
		}
	}
	if x.Fixed64 != nil {
		v := *x.Fixed64
		if v < 0x1 || v > 0x5 {
			el = append(el, fmt.Errorf("invalid value for fixed64 of examples.OptionalScalars: %v", v))
		}
	}
	if x.Sfixed32 != nil {
		v := *x.Sfixed32
		if v <= 1 || v >= 5 {
			el = append(el, fmt.Errorf("invalid value for sfixed32 of examples.OptionalScalars: %v", v))
		}
	}
	if x.Sfixed64 != nil {
		v := *x.Sfixed64
		if v < 1 || v > 5 {
			el = append(el, fmt.Errorf("invalid value for sfixed64 of examples.OptionalScalars: %v", v))
		}
	}
	if x.String_ != nil {
		v := *x.String_
		v = norm.NFC.String(v)
		if v != "" {
			if vlen := utf8.RuneCountInString(v); vlen < 0x3 {
				el = append(el, fmt.Errorf("invalid value for string of examples.OptionalScalars: %v", v))
			}
		}
		x.String_ = &v
	}
	if v := x.Bytes; v != nil {
		if vlen := len(v); vlen > 0xa {
			el = append(el, fmt.Errorf("invalid value for bytes of examples.OptionalScalars: %v", v))
		}
	}

	if err := validate.CallValidateCustom(x); err != nil {
		if v, ok := err.(interface{ Unwrap() []error }); ok {
			el = append(el, v.Unwrap()...)
		} else {
			el = append(el, err)
		}
	}

	if len(el) == 0 {
		return nil
	}
	return errors.Join(el...)
}

func (x *RepeatedScalars) Validate() error {
	var el []error
	for _, v := range x.Float {
		if v >= 3.2 {
			el = append(el, fmt.Errorf("invalid value for float of examples.RepeatedScalars: %v", v))
		}
	}
	if len(x.Float) < 0x1 {
		el = append(el, fmt.Errorf("too few items in float of RepeatedScalars"))
	}
	for _, v := range x.Double {
		if v <= 3.2 {
			el = append(el, fmt.Errorf("invalid value for double of examples.RepeatedScalars: %v", v))
		}
	}
	if len(x.Double) > 0x3 {
		el = append(el, fmt.Errorf("too many items in double of RepeatedScalars"))
	}
	for i, v := range x.String_ {
		v = norm.NFC.String(v)
		x.String_[i] = v
	}
	if len(x.String_) < 0x2 {
		el = append(el, fmt.Errorf("too few items in string of RepeatedScalars"))
	}

	if err := validate.CallValidateCustom(x); err != nil {
		if v, ok := err.(interface{ Unwrap() []error }); ok {
			el = append(el, v.Unwrap()...)
		} else {
			el = append(el, err)
		}
	}

	if len(el) == 0 {
		return nil
	}
	return errors.Join(el...)
}

func (x *Strings) Validate() error {
	var el []error
	if v := x.S1; true {
		v = norm.NFC.String(v)
		x.S1 = v
	}
	if v := x.S2; true {
		v = norm.NFD.String(v)
		x.S2 = v
	}
	if v := x.S3; true {
		v = norm.NFC.String(v)
		if v != "" {
			if vlen := utf8.RuneCountInString(v); vlen < 0xa {
				el = append(el, fmt.Errorf("invalid value for s3 of examples.Strings: %v", v))
			}
		}
		x.S3 = v
	}
	if v := x.S4; true {
		if v2, err := precis.UsernameCaseMapped.String(v); err != nil {
			el = append(el, fmt.Errorf("invalid value for s4 of examples.Strings: %v, %w", v, err))
		} else {
			v = v2
		}
		x.S4 = v
	}
	if v := x.S5; true {
		if v2, err := precis.UsernameCasePreserved.String(v); err != nil {
			el = append(el, fmt.Errorf("invalid value for s5 of examples.Strings: %v, %w", v, err))
		} else {
			v = v2
		}
		x.S5 = v
	}
	if v := x.S6; true {
		if v2, err := precis.OpaqueString.String(v); err != nil {
			el = append(el, fmt.Errorf("invalid value for s6 of examples.Strings: %v, %w", v, err))
		} else {
			v = v2
		}
		x.S6 = v
	}
	if v := x.S7; true {
		v = norm.NFC.String(v)
		if !regex_Strings_S7.MatchString(v) {
			el = append(el, fmt.Errorf("invalid value for s7 of examples.Strings: %v", v))
		}
		x.S7 = v
	}
	if v := x.S8; true {
		v = norm.NFC.String(v)
		if a, err := mail.ParseAddress(v); err != nil {
			el = append(el, fmt.Errorf("invalid value for s8 of examples.Strings: %v, %w", v, err))
		} else if a.Name != "" {
			el = append(el, fmt.Errorf("invalid value for s8 of examples.Strings: %v", v))
		} else {
			v = a.Address
		}
		x.S8 = v
	}
	if v := x.S9; true {
		v = norm.NFC.String(v)
		if u, err := url.Parse(v); err != nil {
			el = append(el, fmt.Errorf("invalid value for s9 of examples.Strings: %v, %w", v, err))
		} else if !u.IsAbs() {
			el = append(el, fmt.Errorf("invalid value for s9 of examples.Strings: %v", v))
		} else {
			v = u.String()
		}
		x.S9 = v
	}
	if v := x.S10; true {
		v = norm.NFC.String(v)
		if !validate.E164Pattern.MatchString(v) {
			el = append(el, fmt.Errorf("invalid value for s10 of examples.Strings: %v", v))
		} else if len(v)-strings.Count(v, "-") > 16 {
			el = append(el, fmt.Errorf("invalid value for s10 of examples.Strings: %v", v))
		}
		x.S10 = v
	}

	if err := validate.CallValidateCustom(x); err != nil {
		if v, ok := err.(interface{ Unwrap() []error }); ok {
			el = append(el, v.Unwrap()...)
		} else {
			el = append(el, err)
		}
	}

	if len(el) == 0 {
		return nil
	}
	return errors.Join(el...)
}

func (x *Maps) Validate() error {
	var el []error
	for k, v := range x.Map1 {
		delete(x.Map1, k)
		x.Map1[norm.NFC.String(k)] = v
	}
	for _, v := range x.Map1 {
		if v <= 3 {
			el = append(el, fmt.Errorf("invalid value for map1 of examples.Maps: %v", v))
		}
	}
	if len(x.Map1) < 0x1 {
		el = append(el, fmt.Errorf("too few items in map1 of Maps"))
	}
	for k, v := range x.Map2 {
		delete(x.Map2, k)
		x.Map2[norm.NFC.String(k)] = v
	}
	for _, v := range x.Map2 {
		if v == nil {
			el = append(el, errors.New("required field map2 of examples.Maps is missing"))
		}
		if v != nil {
			if err := validate.CallValidate(v); err != nil {
				if v, ok := err.(interface{ Unwrap() []error }); ok {
					el = append(el, v.Unwrap()...)
				} else {
					el = append(el, err)
				}
			}
		}
	}
	for i, v := range x.Map3 {
		v = norm.NFC.String(v)
		x.Map3[i] = v
	}
	for k, v := range x.Map4 {
		delete(x.Map4, k)
		x.Map4[norm.NFC.String(k)] = v
	}
	for _, v := range x.Map4 {
		if v != nil {
			if err := validate.CallValidate(v); err != nil {
				if v, ok := err.(interface{ Unwrap() []error }); ok {
					el = append(el, v.Unwrap()...)
				} else {
					el = append(el, err)
				}
			}
		}
	}

	if err := validate.CallValidateCustom(x); err != nil {
		if v, ok := err.(interface{ Unwrap() []error }); ok {
			el = append(el, v.Unwrap()...)
		} else {
			el = append(el, err)
		}
	}

	if len(el) == 0 {
		return nil
	}
	return errors.Join(el...)
}

func (x *Enums) Validate() error {
	var el []error
	if v := x.E1; true {
		if v == Enums_Enum(0) {
			el = append(el, errors.New("field e1 of examples.Enums must not be zero-value"))
		}
	}
	if v := x.E2; true {
		if _, ok := Enums_Enum_name[int32(v)]; !ok {
			el = append(el, fmt.Errorf("invalid value for e2 of examples.Enums: %v", v))
		}
	}
	for _, v := range x.E3 {
		if v == Enums_Enum(0) {
			el = append(el, errors.New("field e3 of examples.Enums must not be zero-value"))
		}
	}
	if len(x.E3) < 0x2 {
		el = append(el, fmt.Errorf("too few items in e3 of Enums"))
	}
	if x.E4 != nil {
		v := *x.E4
		if v == Enums_Enum(0) {
			el = append(el, errors.New("field e4 of examples.Enums must not be zero-value"))
		}
		if _, ok := Enums_Enum_name[int32(v)]; !ok {
			el = append(el, fmt.Errorf("invalid value for e4 of examples.Enums: %v", v))
		}
	}

	if err := validate.CallValidateCustom(x); err != nil {
		if v, ok := err.(interface{ Unwrap() []error }); ok {
			el = append(el, v.Unwrap()...)
		} else {
			el = append(el, err)
		}
	}

	if len(el) == 0 {
		return nil
	}
	return errors.Join(el...)
}

func (x *Oneofs) Validate() error {
	var el []error
	switch x := x.O1.(type) {
	case *Oneofs_Int32:
		if v := x.Int32; true {
			if v > -3 {
				el = append(el, fmt.Errorf("invalid value for int32 of examples.Oneofs: %v", v))
			}
		}
	case *Oneofs_String_:
		if v := x.String_; true {
			v = norm.NFC.String(v)
			x.String_ = v
		}
	default:
		_ = x
	}
	if x.O2 == nil {
		el = append(el, fmt.Errorf("one of the fields is required in o2 of examples.Oneofs"))
	}
	switch x := x.O2.(type) {
	case *Oneofs_Ts:
		if v := x.Ts; true {
			if v != nil {
				if err := validate.CallValidate(v); err != nil {
					if v, ok := err.(interface{ Unwrap() []error }); ok {
						el = append(el, v.Unwrap()...)
					} else {
						el = append(el, err)
					}
				}
			}
		}
	case *Oneofs_Bool:
	default:
		_ = x
	}

	if err := validate.CallValidateCustom(x); err != nil {
		if v, ok := err.(interface{ Unwrap() []error }); ok {
			el = append(el, v.Unwrap()...)
		} else {
			el = append(el, err)
		}
	}

	if len(el) == 0 {
		return nil
	}
	return errors.Join(el...)
}

func (x *Composed) Validate() error {
	var el []error
	if v := x.Ignored; true {
		if v == nil {
			el = append(el, errors.New("required field ignored of examples.Composed is missing"))
		}
		if v != nil {
			if err := validate.CallValidate(v); err != nil {
				if v, ok := err.(interface{ Unwrap() []error }); ok {
					el = append(el, v.Unwrap()...)
				} else {
					el = append(el, err)
				}
			}
		}
	}
	if v := x.Scalars; true {
		if v != nil {
			if err := validate.CallValidate(v); err != nil {
				if v, ok := err.(interface{ Unwrap() []error }); ok {
					el = append(el, v.Unwrap()...)
				} else {
					el = append(el, err)
				}
			}
		}
	}
	for _, v := range x.Maps {
		if v != nil {
			if err := validate.CallValidate(v); err != nil {
				if v, ok := err.(interface{ Unwrap() []error }); ok {
					el = append(el, v.Unwrap()...)
				} else {
					el = append(el, err)
				}
			}
		}
	}
	for _, v := range x.Enums {
		if v == nil {
			el = append(el, errors.New("required field enums of examples.Composed is missing"))
		}
		if v != nil {
			if err := validate.CallValidate(v); err != nil {
				if v, ok := err.(interface{ Unwrap() []error }); ok {
					el = append(el, v.Unwrap()...)
				} else {
					el = append(el, err)
				}
			}
		}
	}

	if err := validate.CallValidateCustom(x); err != nil {
		if v, ok := err.(interface{ Unwrap() []error }); ok {
			el = append(el, v.Unwrap()...)
		} else {
			el = append(el, err)
		}
	}

	if len(el) == 0 {
		return nil
	}
	return errors.Join(el...)
}

func (x *Nested) Validate() error {
	var el []error
	if v := x.Inner; true {
		if v == nil {
			el = append(el, errors.New("required field inner of examples.Nested is missing"))
		}
		if v != nil {
			if err := validate.CallValidate(v); err != nil {
				if v, ok := err.(interface{ Unwrap() []error }); ok {
					el = append(el, v.Unwrap()...)
				} else {
					el = append(el, err)
				}
			}
		}
	}

	if err := validate.CallValidateCustom(x); err != nil {
		if v, ok := err.(interface{ Unwrap() []error }); ok {
			el = append(el, v.Unwrap()...)
		} else {
			el = append(el, err)
		}
	}

	if len(el) == 0 {
		return nil
	}
	return errors.Join(el...)
}
func (x *Nested_Inner) Validate() error {
	var el []error
	if v := x.Int32; true {
		if v <= 3 {
			el = append(el, fmt.Errorf("invalid value for int32 of examples.Nested.Inner: %v", v))
		}
	}

	if err := validate.CallValidateCustom(x); err != nil {
		if v, ok := err.(interface{ Unwrap() []error }); ok {
			el = append(el, v.Unwrap()...)
		} else {
			el = append(el, err)
		}
	}

	if len(el) == 0 {
		return nil
	}
	return errors.Join(el...)
}

var (
	regex_Strings_S7 = regexp.MustCompile("^abc")
)
