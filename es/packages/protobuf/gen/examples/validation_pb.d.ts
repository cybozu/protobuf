// @generated by protoc-gen-es v1.3.0 with parameter "target=js+dts"
// @generated from file examples/validation.proto (package examples, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * This message is marked ignored, so no validation method is generated.
 *
 * @generated from message examples.Ignored
 */
export declare class Ignored extends Message<Ignored> {
  /**
   * @generated from field: string foo = 1;
   */
  foo: string;

  /**
   * no effect
   *
   * @generated from field: int32 bar = 2;
   */
  bar: number;

  constructor(data?: PartialMessage<Ignored>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "examples.Ignored";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Ignored;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Ignored;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Ignored;

  static equals(a: Ignored | PlainMessage<Ignored> | undefined, b: Ignored | PlainMessage<Ignored> | undefined): boolean;
}

/**
 * All scalar types can have constraint rules except for bools.
 *
 * @generated from message examples.Scalars
 */
export declare class Scalars extends Message<Scalars> {
  /**
   * @generated from field: float float = 1;
   */
  float: number;

  /**
   * @generated from field: double double = 2;
   */
  double: number;

  /**
   * @generated from field: int32 int32 = 3;
   */
  int32: number;

  /**
   * @generated from field: int64 int64 = 4;
   */
  int64: bigint;

  /**
   * @generated from field: uint32 uint32 = 5;
   */
  uint32: number;

  /**
   * @generated from field: uint64 uint64 = 6;
   */
  uint64: bigint;

  /**
   * @generated from field: sint32 sint32 = 7;
   */
  sint32: number;

  /**
   * @generated from field: sint64 sint64 = 8;
   */
  sint64: bigint;

  /**
   * @generated from field: fixed32 fixed32 = 9;
   */
  fixed32: number;

  /**
   * @generated from field: fixed64 fixed64 = 10;
   */
  fixed64: bigint;

  /**
   * @generated from field: sfixed32 sfixed32 = 11;
   */
  sfixed32: number;

  /**
   * @generated from field: sfixed64 sfixed64 = 12;
   */
  sfixed64: bigint;

  /**
   * no available rules for bools
   *
   * @generated from field: bool bool = 13;
   */
  bool: boolean;

  /**
   * @generated from field: string string = 14;
   */
  string: string;

  /**
   * @generated from field: bytes bytes = 15;
   */
  bytes: Uint8Array;

  constructor(data?: PartialMessage<Scalars>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "examples.Scalars";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Scalars;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Scalars;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Scalars;

  static equals(a: Scalars | PlainMessage<Scalars> | undefined, b: Scalars | PlainMessage<Scalars> | undefined): boolean;
}

/**
 * rules for optional fields are enforced only if the field is set.
 *
 * @generated from message examples.OptionalScalars
 */
export declare class OptionalScalars extends Message<OptionalScalars> {
  /**
   * @generated from field: optional float float = 1;
   */
  float?: number;

  /**
   * @generated from field: optional double double = 2;
   */
  double?: number;

  /**
   * @generated from field: optional int32 int32 = 3;
   */
  int32?: number;

  /**
   * @generated from field: optional int64 int64 = 4;
   */
  int64?: bigint;

  /**
   * @generated from field: optional uint32 uint32 = 5;
   */
  uint32?: number;

  /**
   * @generated from field: optional uint64 uint64 = 6;
   */
  uint64?: bigint;

  /**
   * @generated from field: optional sint32 sint32 = 7;
   */
  sint32?: number;

  /**
   * @generated from field: optional sint64 sint64 = 8;
   */
  sint64?: bigint;

  /**
   * @generated from field: optional fixed32 fixed32 = 9;
   */
  fixed32?: number;

  /**
   * @generated from field: optional fixed64 fixed64 = 10;
   */
  fixed64?: bigint;

  /**
   * @generated from field: optional sfixed32 sfixed32 = 11;
   */
  sfixed32?: number;

  /**
   * @generated from field: optional sfixed64 sfixed64 = 12;
   */
  sfixed64?: bigint;

  /**
   * no available rules for bool
   *
   * @generated from field: optional bool bool = 13;
   */
  bool?: boolean;

  /**
   * @generated from field: optional string string = 14;
   */
  string?: string;

  /**
   * @generated from field: optional bytes bytes = 15;
   */
  bytes?: Uint8Array;

  constructor(data?: PartialMessage<OptionalScalars>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "examples.OptionalScalars";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OptionalScalars;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OptionalScalars;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OptionalScalars;

  static equals(a: OptionalScalars | PlainMessage<OptionalScalars> | undefined, b: OptionalScalars | PlainMessage<OptionalScalars> | undefined): boolean;
}

/**
 * @generated from message examples.RepeatedScalars
 */
export declare class RepeatedScalars extends Message<RepeatedScalars> {
  /**
   * a repeated field can specify `repeated` constraints like this
   *
   * @generated from field: repeated float float = 1;
   */
  float: number[];

  /**
   * or this
   *
   * @generated from field: repeated double double = 2;
   */
  double: number[];

  /**
   * or this.
   *
   * @generated from field: repeated string string = 3;
   */
  string: string[];

  constructor(data?: PartialMessage<RepeatedScalars>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "examples.RepeatedScalars";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedScalars;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedScalars;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedScalars;

  static equals(a: RepeatedScalars | PlainMessage<RepeatedScalars> | undefined, b: RepeatedScalars | PlainMessage<RepeatedScalars> | undefined): boolean;
}

/**
 * Strings have the richest set of constraint rules.
 *
 * @generated from message examples.Strings
 */
export declare class Strings extends Message<Strings> {
  /**
   * NFC normalization is applied if no options are given.
   *
   * @generated from field: string s1 = 1;
   */
  s1: string;

  /**
   * normalize into the NFD form.
   *
   * @generated from field: string s2 = 2;
   */
  s2: string;

  /**
   * enforce the minimum length of the string if the string is NOT empty.
   * This check is done after NFC normalization.
   *
   * @generated from field: string s3 = 3;
   */
  s3: string;

  /**
   * normalize and validate the string with a PRECIS profile.
   *
   * @generated from field: string s4 = 4;
   */
  s4: string;

  /**
   * normalize and validate the string with a PRECIS profile.
   *
   * @generated from field: string s5 = 5;
   */
  s5: string;

  /**
   * normalize and validate the string with a PRECIS profile.
   *
   * @generated from field: string s6 = 6;
   */
  s6: string;

  /**
   * enforce that the string matches a regular expresson. The regular expression syntax is RE2.
   * See https://github.com/google/re2/wiki/Syntax
   *
   * @generated from field: string s7 = 7;
   */
  s7: string;

  /**
   * enforce that the string is a valid email address as defined in RFC 5322.
   *
   * @generated from field: string s8 = 8;
   */
  s8: string;

  /**
   * enforce that the string is a valid URI as defined in RFC 3986.
   * The string will also be canonicalized.
   *
   * @generated from field: string s9 = 9;
   */
  s9: string;

  /**
   * enforce that the string is a valid telephone number as defined by E.164.
   * An example is "+81-80-0000-0000".
   *
   * @generated from field: string s10 = 10;
   */
  s10: string;

  constructor(data?: PartialMessage<Strings>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "examples.Strings";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Strings;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Strings;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Strings;

  static equals(a: Strings | PlainMessage<Strings> | undefined, b: Strings | PlainMessage<Strings> | undefined): boolean;
}

/**
 * In addition to the validation code generated from the protobuf options,
 * this message implements a custom validation. See `example_custom.go`
 * in the same directory.
 *
 * @generated from message examples.Maps
 */
export declare class Maps extends Message<Maps> {
  /**
   * you can put a constraint for map and a constraint for the value type as follows.
   *
   * @generated from field: map<string, int32> map1 = 1;
   */
  map1: { [key: string]: number };

  /**
   * or either one of them. The following enforces that the timestamp is set.
   *
   * @generated from field: map<string, google.protobuf.Timestamp> map2 = 2;
   */
  map2: { [key: string]: Timestamp };

  /**
   * string values are normalized into the NFC form even if there's no rules specified.
   *
   * @generated from field: map<uint32, string> map3 = 3;
   */
  map3: { [key: number]: string };

  /**
   * if the map key is a string, it is normalized into the NFC.
   * if the map vakue is a message, fields in it are always normalized/validated.
   *
   * @generated from field: map<string, examples.Scalars> map4 = 4;
   */
  map4: { [key: string]: Scalars };

  constructor(data?: PartialMessage<Maps>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "examples.Maps";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Maps;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Maps;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Maps;

  static equals(a: Maps | PlainMessage<Maps> | undefined, b: Maps | PlainMessage<Maps> | undefined): boolean;
}

/**
 * @generated from message examples.Enums
 */
export declare class Enums extends Message<Enums> {
  /**
   * enforces that `e1` is not the zero value.
   *
   * @generated from field: examples.Enums.Enum e1 = 1;
   */
  e1: Enums_Enum;

  /**
   * enforces that `e2` is one of the defined enum value.
   *
   * @generated from field: examples.Enums.Enum e2 = 2;
   */
  e2: Enums_Enum;

  /**
   * enforces that `e3` is one of the defined enum value other than zero.
   *
   * @generated from field: repeated examples.Enums.Enum e3 = 3;
   */
  e3: Enums_Enum[];

  /**
   * enforces that `e4` is, if given, one of the defined enum value other than zero.
   *
   * @generated from field: optional examples.Enums.Enum e4 = 4;
   */
  e4?: Enums_Enum;

  constructor(data?: PartialMessage<Enums>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "examples.Enums";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Enums;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Enums;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Enums;

  static equals(a: Enums | PlainMessage<Enums> | undefined, b: Enums | PlainMessage<Enums> | undefined): boolean;
}

/**
 * @generated from enum examples.Enums.Enum
 */
export declare enum Enums_Enum {
  /**
   * @generated from enum value: E_UNSPECIFIED = 0;
   */
  E_UNSPECIFIED = 0,

  /**
   * @generated from enum value: E_VAL1 = 1;
   */
  E_VAL1 = 1,

  /**
   * @generated from enum value: E_VAL100 = 100;
   */
  E_VAL100 = 100,
}

/**
 * @generated from message examples.Oneofs
 */
export declare class Oneofs extends Message<Oneofs> {
  /**
   * @generated from oneof examples.Oneofs.o1
   */
  o1: {
    /**
     * @generated from field: int32 int32 = 1;
     */
    value: number;
    case: "int32";
  } | {
    /**
     * @generated from field: string string = 2;
     */
    value: string;
    case: "string";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from oneof examples.Oneofs.o2
   */
  o2: {
    /**
     * @generated from field: google.protobuf.Timestamp ts = 3;
     */
    value: Timestamp;
    case: "ts";
  } | {
    /**
     * @generated from field: bool bool = 4;
     */
    value: boolean;
    case: "bool";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Oneofs>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "examples.Oneofs";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Oneofs;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Oneofs;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Oneofs;

  static equals(a: Oneofs | PlainMessage<Oneofs> | undefined, b: Oneofs | PlainMessage<Oneofs> | undefined): boolean;
}

/**
 * message type fields are normalized/validated recursively.
 *
 * @generated from message examples.Composed
 */
export declare class Composed extends Message<Composed> {
  /**
   * enforces that `ignored` is set.
   *
   * @generated from field: examples.Ignored ignored = 1;
   */
  ignored?: Ignored;

  /**
   * @generated from field: examples.Scalars scalars = 2;
   */
  scalars?: Scalars;

  /**
   * @generated from field: repeated examples.Maps maps = 3;
   */
  maps: Maps[];

  /**
   * enforces that all messages in `enums` are set.
   *
   * @generated from field: repeated examples.Enums enums = 4;
   */
  enums: Enums[];

  constructor(data?: PartialMessage<Composed>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "examples.Composed";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Composed;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Composed;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Composed;

  static equals(a: Composed | PlainMessage<Composed> | undefined, b: Composed | PlainMessage<Composed> | undefined): boolean;
}

/**
 * @generated from message examples.Nested
 */
export declare class Nested extends Message<Nested> {
  /**
   * @generated from field: examples.Nested.Inner inner = 1;
   */
  inner?: Nested_Inner;

  constructor(data?: PartialMessage<Nested>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "examples.Nested";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Nested;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Nested;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Nested;

  static equals(a: Nested | PlainMessage<Nested> | undefined, b: Nested | PlainMessage<Nested> | undefined): boolean;
}

/**
 * Inner will also be validated.
 *
 * @generated from message examples.Nested.Inner
 */
export declare class Nested_Inner extends Message<Nested_Inner> {
  /**
   * @generated from field: int32 int32 = 1;
   */
  int32: number;

  constructor(data?: PartialMessage<Nested_Inner>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "examples.Nested.Inner";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Nested_Inner;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Nested_Inner;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Nested_Inner;

  static equals(a: Nested_Inner | PlainMessage<Nested_Inner> | undefined, b: Nested_Inner | PlainMessage<Nested_Inner> | undefined): boolean;
}

