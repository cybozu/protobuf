// @generated by protoc-gen-es v1.3.0 with parameter "target=js+dts"
// @generated from file examples/validation.proto (package examples, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * This message is marked ignored, so no validation method is generated.
 *
 * @generated from message examples.Ignored
 */
export const Ignored = proto3.makeMessageType(
  "examples.Ignored",
  () => [
    { no: 1, name: "foo", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "bar", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ],
);

/**
 * All scalar types can have constraint rules except for bools.
 *
 * @generated from message examples.Scalars
 */
export const Scalars = proto3.makeMessageType(
  "examples.Scalars",
  () => [
    { no: 1, name: "float", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "int32", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "int64", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "uint32", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "uint64", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "sint32", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
    { no: 8, name: "sint64", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
    { no: 9, name: "fixed32", kind: "scalar", T: 7 /* ScalarType.FIXED32 */ },
    { no: 10, name: "fixed64", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 11, name: "sfixed32", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */ },
    { no: 12, name: "sfixed64", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */ },
    { no: 13, name: "bool", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * rules for optional fields are enforced only if the field is set.
 *
 * @generated from message examples.OptionalScalars
 */
export const OptionalScalars = proto3.makeMessageType(
  "examples.OptionalScalars",
  () => [
    { no: 1, name: "float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 2, name: "double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 3, name: "int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "int64", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 5, name: "uint32", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 6, name: "uint64", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 7, name: "sint32", kind: "scalar", T: 17 /* ScalarType.SINT32 */, opt: true },
    { no: 8, name: "sint64", kind: "scalar", T: 18 /* ScalarType.SINT64 */, opt: true },
    { no: 9, name: "fixed32", kind: "scalar", T: 7 /* ScalarType.FIXED32 */, opt: true },
    { no: 10, name: "fixed64", kind: "scalar", T: 6 /* ScalarType.FIXED64 */, opt: true },
    { no: 11, name: "sfixed32", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */, opt: true },
    { no: 12, name: "sfixed64", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */, opt: true },
    { no: 13, name: "bool", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 14, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 15, name: "bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
  ],
);

/**
 * @generated from message examples.RepeatedScalars
 */
export const RepeatedScalars = proto3.makeMessageType(
  "examples.RepeatedScalars",
  () => [
    { no: 1, name: "float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
    { no: 2, name: "double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
    { no: 3, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ],
);

/**
 * Strings have the richest set of constraint rules.
 *
 * @generated from message examples.Strings
 */
export const Strings = proto3.makeMessageType(
  "examples.Strings",
  () => [
    { no: 1, name: "s1", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "s2", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "s3", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "s4", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "s5", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "s6", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "s7", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "s8", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "s9", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "s10", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * In addition to the validation code generated from the protobuf options,
 * this message implements a custom validation. See `example_custom.go`
 * in the same directory.
 *
 * @generated from message examples.Maps
 */
export const Maps = proto3.makeMessageType(
  "examples.Maps",
  () => [
    { no: 1, name: "map1", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 5 /* ScalarType.INT32 */} },
    { no: 2, name: "map2", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Timestamp} },
    { no: 3, name: "map3", kind: "map", K: 13 /* ScalarType.UINT32 */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 4, name: "map4", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Scalars} },
  ],
);

/**
 * @generated from message examples.Enums
 */
export const Enums = proto3.makeMessageType(
  "examples.Enums",
  () => [
    { no: 1, name: "e1", kind: "enum", T: proto3.getEnumType(Enums_Enum) },
    { no: 2, name: "e2", kind: "enum", T: proto3.getEnumType(Enums_Enum) },
    { no: 3, name: "e3", kind: "enum", T: proto3.getEnumType(Enums_Enum), repeated: true },
    { no: 4, name: "e4", kind: "enum", T: proto3.getEnumType(Enums_Enum), opt: true },
  ],
);

/**
 * @generated from enum examples.Enums.Enum
 */
export const Enums_Enum = proto3.makeEnum(
  "examples.Enums.Enum",
  [
    {no: 0, name: "E_UNSPECIFIED"},
    {no: 1, name: "E_VAL1"},
    {no: 100, name: "E_VAL100"},
  ],
);

/**
 * @generated from message examples.Oneofs
 */
export const Oneofs = proto3.makeMessageType(
  "examples.Oneofs",
  () => [
    { no: 1, name: "int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "o1" },
    { no: 2, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "o1" },
    { no: 3, name: "ts", kind: "message", T: Timestamp, oneof: "o2" },
    { no: 4, name: "bool", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "o2" },
  ],
);

/**
 * message type fields are normalized/validated recursively.
 *
 * @generated from message examples.Composed
 */
export const Composed = proto3.makeMessageType(
  "examples.Composed",
  () => [
    { no: 1, name: "ignored", kind: "message", T: Ignored },
    { no: 2, name: "scalars", kind: "message", T: Scalars },
    { no: 3, name: "maps", kind: "message", T: Maps, repeated: true },
    { no: 4, name: "enums", kind: "message", T: Enums, repeated: true },
  ],
);

/**
 * @generated from message examples.Nested
 */
export const Nested = proto3.makeMessageType(
  "examples.Nested",
  () => [
    { no: 1, name: "inner", kind: "message", T: Nested_Inner },
  ],
);

/**
 * Inner will also be validated.
 *
 * @generated from message examples.Nested.Inner
 */
export const Nested_Inner = proto3.makeMessageType(
  "examples.Nested.Inner",
  () => [
    { no: 1, name: "int32", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ],
  {localName: "Nested_Inner"},
);

