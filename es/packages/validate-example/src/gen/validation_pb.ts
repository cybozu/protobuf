// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file validation.proto (package examples, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";

/**
 * This message is marked ignored, so no validation method is generated.
 *
 * @generated from message examples.Ignored
 */
export class Ignored extends Message<Ignored> {
  /**
   * @generated from field: string foo = 1;
   */
  foo = "";

  /**
   * no effect
   *
   * @generated from field: int32 bar = 2;
   */
  bar = 0;

  constructor(data?: PartialMessage<Ignored>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "examples.Ignored";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "foo", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "bar", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Ignored {
    return new Ignored().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Ignored {
    return new Ignored().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Ignored {
    return new Ignored().fromJsonString(jsonString, options);
  }

  static equals(a: Ignored | PlainMessage<Ignored> | undefined, b: Ignored | PlainMessage<Ignored> | undefined): boolean {
    return proto3.util.equals(Ignored, a, b);
  }
}

/**
 * All scalar types can have constraint rules except for bools.
 *
 * @generated from message examples.Scalars
 */
export class Scalars extends Message<Scalars> {
  /**
   * @generated from field: float float = 1;
   */
  float = 0;

  /**
   * @generated from field: double double = 2;
   */
  double = 0;

  /**
   * @generated from field: int32 int32 = 3;
   */
  int32 = 0;

  /**
   * @generated from field: int64 int64 = 4;
   */
  int64 = protoInt64.zero;

  /**
   * @generated from field: uint32 uint32 = 5;
   */
  uint32 = 0;

  /**
   * @generated from field: uint64 uint64 = 6;
   */
  uint64 = protoInt64.zero;

  /**
   * @generated from field: sint32 sint32 = 7;
   */
  sint32 = 0;

  /**
   * @generated from field: sint64 sint64 = 8;
   */
  sint64 = protoInt64.zero;

  /**
   * @generated from field: fixed32 fixed32 = 9;
   */
  fixed32 = 0;

  /**
   * @generated from field: fixed64 fixed64 = 10;
   */
  fixed64 = protoInt64.zero;

  /**
   * @generated from field: sfixed32 sfixed32 = 11;
   */
  sfixed32 = 0;

  /**
   * @generated from field: sfixed64 sfixed64 = 12;
   */
  sfixed64 = protoInt64.zero;

  /**
   * no available rules for bools
   *
   * @generated from field: bool bool = 13;
   */
  bool = false;

  /**
   * @generated from field: string string = 14;
   */
  string = "";

  /**
   * @generated from field: bytes bytes = 15;
   */
  bytes = new Uint8Array(0);

  constructor(data?: PartialMessage<Scalars>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "examples.Scalars";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "float", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "int32", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "int64", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "uint32", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "uint64", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "sint32", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
    { no: 8, name: "sint64", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
    { no: 9, name: "fixed32", kind: "scalar", T: 7 /* ScalarType.FIXED32 */ },
    { no: 10, name: "fixed64", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 11, name: "sfixed32", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */ },
    { no: 12, name: "sfixed64", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */ },
    { no: 13, name: "bool", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Scalars {
    return new Scalars().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Scalars {
    return new Scalars().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Scalars {
    return new Scalars().fromJsonString(jsonString, options);
  }

  static equals(a: Scalars | PlainMessage<Scalars> | undefined, b: Scalars | PlainMessage<Scalars> | undefined): boolean {
    return proto3.util.equals(Scalars, a, b);
  }
}

/**
 * rules for optional fields are enforced only if the field is set.
 *
 * @generated from message examples.OptionalScalars
 */
export class OptionalScalars extends Message<OptionalScalars> {
  /**
   * @generated from field: optional float float = 1;
   */
  float?: number;

  /**
   * @generated from field: optional double double = 2;
   */
  double?: number;

  /**
   * @generated from field: optional int32 int32 = 3;
   */
  int32?: number;

  /**
   * @generated from field: optional int64 int64 = 4;
   */
  int64?: bigint;

  /**
   * @generated from field: optional uint32 uint32 = 5;
   */
  uint32?: number;

  /**
   * @generated from field: optional uint64 uint64 = 6;
   */
  uint64?: bigint;

  /**
   * @generated from field: optional sint32 sint32 = 7;
   */
  sint32?: number;

  /**
   * @generated from field: optional sint64 sint64 = 8;
   */
  sint64?: bigint;

  /**
   * @generated from field: optional fixed32 fixed32 = 9;
   */
  fixed32?: number;

  /**
   * @generated from field: optional fixed64 fixed64 = 10;
   */
  fixed64?: bigint;

  /**
   * @generated from field: optional sfixed32 sfixed32 = 11;
   */
  sfixed32?: number;

  /**
   * @generated from field: optional sfixed64 sfixed64 = 12;
   */
  sfixed64?: bigint;

  /**
   * no available rules for bool
   *
   * @generated from field: optional bool bool = 13;
   */
  bool?: boolean;

  /**
   * @generated from field: optional string string = 14;
   */
  string?: string;

  /**
   * @generated from field: optional bytes bytes = 15;
   */
  bytes?: Uint8Array;

  constructor(data?: PartialMessage<OptionalScalars>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "examples.OptionalScalars";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 2, name: "double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 3, name: "int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "int64", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 5, name: "uint32", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 6, name: "uint64", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 7, name: "sint32", kind: "scalar", T: 17 /* ScalarType.SINT32 */, opt: true },
    { no: 8, name: "sint64", kind: "scalar", T: 18 /* ScalarType.SINT64 */, opt: true },
    { no: 9, name: "fixed32", kind: "scalar", T: 7 /* ScalarType.FIXED32 */, opt: true },
    { no: 10, name: "fixed64", kind: "scalar", T: 6 /* ScalarType.FIXED64 */, opt: true },
    { no: 11, name: "sfixed32", kind: "scalar", T: 15 /* ScalarType.SFIXED32 */, opt: true },
    { no: 12, name: "sfixed64", kind: "scalar", T: 16 /* ScalarType.SFIXED64 */, opt: true },
    { no: 13, name: "bool", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 14, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 15, name: "bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OptionalScalars {
    return new OptionalScalars().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OptionalScalars {
    return new OptionalScalars().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OptionalScalars {
    return new OptionalScalars().fromJsonString(jsonString, options);
  }

  static equals(a: OptionalScalars | PlainMessage<OptionalScalars> | undefined, b: OptionalScalars | PlainMessage<OptionalScalars> | undefined): boolean {
    return proto3.util.equals(OptionalScalars, a, b);
  }
}

/**
 * @generated from message examples.RepeatedScalars
 */
export class RepeatedScalars extends Message<RepeatedScalars> {
  /**
   * a repeated field can specify `repeated` constraints like this
   *
   * @generated from field: repeated float float = 1;
   */
  float: number[] = [];

  /**
   * or this
   *
   * @generated from field: repeated double double = 2;
   */
  double: number[] = [];

  /**
   * or this.
   *
   * @generated from field: repeated string string = 3;
   */
  string: string[] = [];

  constructor(data?: PartialMessage<RepeatedScalars>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "examples.RepeatedScalars";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
    { no: 2, name: "double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
    { no: 3, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedScalars {
    return new RepeatedScalars().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedScalars {
    return new RepeatedScalars().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedScalars {
    return new RepeatedScalars().fromJsonString(jsonString, options);
  }

  static equals(a: RepeatedScalars | PlainMessage<RepeatedScalars> | undefined, b: RepeatedScalars | PlainMessage<RepeatedScalars> | undefined): boolean {
    return proto3.util.equals(RepeatedScalars, a, b);
  }
}

/**
 * Strings have the richest set of constraint rules.
 *
 * @generated from message examples.Strings
 */
export class Strings extends Message<Strings> {
  /**
   * NFC normalization is applied if no options are given.
   *
   * @generated from field: string s1 = 1;
   */
  s1 = "";

  /**
   * normalize into the NFD form.
   *
   * @generated from field: string s2 = 2;
   */
  s2 = "";

  /**
   * enforce the minimum length of the string if the string is NOT empty.
   * This check is done after NFC normalization.
   *
   * @generated from field: string s3 = 3;
   */
  s3 = "";

  /**
   * normalize and validate the string with a PRECIS profile.
   *
   * @generated from field: string s4 = 4;
   */
  s4 = "";

  /**
   * normalize and validate the string with a PRECIS profile.
   *
   * @generated from field: string s5 = 5;
   */
  s5 = "";

  /**
   * normalize and validate the string with a PRECIS profile.
   *
   * @generated from field: string s6 = 6;
   */
  s6 = "";

  /**
   * enforce that the string matches a regular expresson. The regular expression syntax is RE2.
   * See https://github.com/google/re2/wiki/Syntax
   *
   * @generated from field: string s7 = 7;
   */
  s7 = "";

  /**
   * enforce that the string is a valid email address as defined in RFC 5322.
   *
   * @generated from field: string s8 = 8;
   */
  s8 = "";

  /**
   * enforce that the string is a valid URI as defined in RFC 3986.
   * The string will also be canonicalized.
   *
   * @generated from field: string s9 = 9;
   */
  s9 = "";

  /**
   * enforce that the string is a valid telephone number as defined by E.164.
   * An example is "+81-80-0000-0000".
   *
   * @generated from field: string s10 = 10;
   */
  s10 = "";

  constructor(data?: PartialMessage<Strings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "examples.Strings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "s1", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "s2", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "s3", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "s4", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "s5", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "s6", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "s7", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "s8", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "s9", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "s10", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Strings {
    return new Strings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Strings {
    return new Strings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Strings {
    return new Strings().fromJsonString(jsonString, options);
  }

  static equals(a: Strings | PlainMessage<Strings> | undefined, b: Strings | PlainMessage<Strings> | undefined): boolean {
    return proto3.util.equals(Strings, a, b);
  }
}

/**
 * In addition to the validation code generated from the protobuf options,
 * this message implements a custom validation. See `example_custom.go`
 * in the same directory.
 *
 * @generated from message examples.Maps
 */
export class Maps extends Message<Maps> {
  /**
   * you can put a constraint for map and a constraint for the value type as follows.
   *
   * @generated from field: map<string, int32> map1 = 1;
   */
  map1: { [key: string]: number } = {};

  /**
   * or either one of them. The following enforces that the timestamp is set.
   *
   * @generated from field: map<string, google.protobuf.Timestamp> map2 = 2;
   */
  map2: { [key: string]: Timestamp } = {};

  /**
   * string values are normalized into the NFC form even if there's no rules specified.
   *
   * @generated from field: map<uint32, string> map3 = 3;
   */
  map3: { [key: number]: string } = {};

  /**
   * if the map key is a string, it is normalized into the NFC.
   * if the map vakue is a message, fields in it are always normalized/validated.
   *
   * @generated from field: map<string, examples.Scalars> map4 = 4;
   */
  map4: { [key: string]: Scalars } = {};

  constructor(data?: PartialMessage<Maps>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "examples.Maps";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "map1", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 5 /* ScalarType.INT32 */} },
    { no: 2, name: "map2", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Timestamp} },
    { no: 3, name: "map3", kind: "map", K: 13 /* ScalarType.UINT32 */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 4, name: "map4", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Scalars} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Maps {
    return new Maps().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Maps {
    return new Maps().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Maps {
    return new Maps().fromJsonString(jsonString, options);
  }

  static equals(a: Maps | PlainMessage<Maps> | undefined, b: Maps | PlainMessage<Maps> | undefined): boolean {
    return proto3.util.equals(Maps, a, b);
  }
}

/**
 * @generated from message examples.Enums
 */
export class Enums extends Message<Enums> {
  /**
   * enforces that `e1` is not the zero value.
   *
   * @generated from field: examples.Enums.Enum e1 = 1;
   */
  e1 = Enums_Enum.E_UNSPECIFIED;

  /**
   * enforces that `e2` is one of the defined enum value.
   *
   * @generated from field: examples.Enums.Enum e2 = 2;
   */
  e2 = Enums_Enum.E_UNSPECIFIED;

  /**
   * enforces that `e3` is one of the defined enum value other than zero.
   *
   * @generated from field: repeated examples.Enums.Enum e3 = 3;
   */
  e3: Enums_Enum[] = [];

  /**
   * enforces that `e4` is, if given, one of the defined enum value other than zero.
   *
   * @generated from field: optional examples.Enums.Enum e4 = 4;
   */
  e4?: Enums_Enum;

  constructor(data?: PartialMessage<Enums>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "examples.Enums";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "e1", kind: "enum", T: proto3.getEnumType(Enums_Enum) },
    { no: 2, name: "e2", kind: "enum", T: proto3.getEnumType(Enums_Enum) },
    { no: 3, name: "e3", kind: "enum", T: proto3.getEnumType(Enums_Enum), repeated: true },
    { no: 4, name: "e4", kind: "enum", T: proto3.getEnumType(Enums_Enum), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Enums {
    return new Enums().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Enums {
    return new Enums().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Enums {
    return new Enums().fromJsonString(jsonString, options);
  }

  static equals(a: Enums | PlainMessage<Enums> | undefined, b: Enums | PlainMessage<Enums> | undefined): boolean {
    return proto3.util.equals(Enums, a, b);
  }
}

/**
 * @generated from enum examples.Enums.Enum
 */
export enum Enums_Enum {
  /**
   * @generated from enum value: E_UNSPECIFIED = 0;
   */
  E_UNSPECIFIED = 0,

  /**
   * @generated from enum value: E_VAL1 = 1;
   */
  E_VAL1 = 1,

  /**
   * @generated from enum value: E_VAL100 = 100;
   */
  E_VAL100 = 100,
}
// Retrieve enum metadata with: proto3.getEnumType(Enums_Enum)
proto3.util.setEnumType(Enums_Enum, "examples.Enums.Enum", [
  { no: 0, name: "E_UNSPECIFIED" },
  { no: 1, name: "E_VAL1" },
  { no: 100, name: "E_VAL100" },
]);

/**
 * @generated from message examples.Oneofs
 */
export class Oneofs extends Message<Oneofs> {
  /**
   * @generated from oneof examples.Oneofs.o1
   */
  o1: {
    /**
     * @generated from field: int32 int32 = 1;
     */
    value: number;
    case: "int32";
  } | {
    /**
     * @generated from field: string string = 2;
     */
    value: string;
    case: "string";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from oneof examples.Oneofs.o2
   */
  o2: {
    /**
     * @generated from field: google.protobuf.Timestamp ts = 3;
     */
    value: Timestamp;
    case: "ts";
  } | {
    /**
     * @generated from field: bool bool = 4;
     */
    value: boolean;
    case: "bool";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Oneofs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "examples.Oneofs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "int32", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "o1" },
    { no: 2, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "o1" },
    { no: 3, name: "ts", kind: "message", T: Timestamp, oneof: "o2" },
    { no: 4, name: "bool", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "o2" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Oneofs {
    return new Oneofs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Oneofs {
    return new Oneofs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Oneofs {
    return new Oneofs().fromJsonString(jsonString, options);
  }

  static equals(a: Oneofs | PlainMessage<Oneofs> | undefined, b: Oneofs | PlainMessage<Oneofs> | undefined): boolean {
    return proto3.util.equals(Oneofs, a, b);
  }
}

/**
 * message type fields are normalized/validated recursively.
 *
 * @generated from message examples.Composed
 */
export class Composed extends Message<Composed> {
  /**
   * enforces that `ignored` is set.
   *
   * @generated from field: examples.Ignored ignored = 1;
   */
  ignored?: Ignored;

  /**
   * @generated from field: examples.Scalars scalars = 2;
   */
  scalars?: Scalars;

  /**
   * @generated from field: repeated examples.Maps maps = 3;
   */
  maps: Maps[] = [];

  /**
   * enforces that all messages in `enums` are set.
   *
   * @generated from field: repeated examples.Enums enums = 4;
   */
  enums: Enums[] = [];

  constructor(data?: PartialMessage<Composed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "examples.Composed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ignored", kind: "message", T: Ignored },
    { no: 2, name: "scalars", kind: "message", T: Scalars },
    { no: 3, name: "maps", kind: "message", T: Maps, repeated: true },
    { no: 4, name: "enums", kind: "message", T: Enums, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Composed {
    return new Composed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Composed {
    return new Composed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Composed {
    return new Composed().fromJsonString(jsonString, options);
  }

  static equals(a: Composed | PlainMessage<Composed> | undefined, b: Composed | PlainMessage<Composed> | undefined): boolean {
    return proto3.util.equals(Composed, a, b);
  }
}

/**
 * @generated from message examples.Nested
 */
export class Nested extends Message<Nested> {
  /**
   * @generated from field: examples.Nested.Inner inner = 1;
   */
  inner?: Nested_Inner;

  constructor(data?: PartialMessage<Nested>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "examples.Nested";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "message", T: Nested_Inner },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Nested {
    return new Nested().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Nested {
    return new Nested().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Nested {
    return new Nested().fromJsonString(jsonString, options);
  }

  static equals(a: Nested | PlainMessage<Nested> | undefined, b: Nested | PlainMessage<Nested> | undefined): boolean {
    return proto3.util.equals(Nested, a, b);
  }
}

/**
 * Inner will also be validated.
 *
 * @generated from message examples.Nested.Inner
 */
export class Nested_Inner extends Message<Nested_Inner> {
  /**
   * @generated from field: int32 int32 = 1;
   */
  int32 = 0;

  constructor(data?: PartialMessage<Nested_Inner>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "examples.Nested.Inner";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "int32", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Nested_Inner {
    return new Nested_Inner().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Nested_Inner {
    return new Nested_Inner().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Nested_Inner {
    return new Nested_Inner().fromJsonString(jsonString, options);
  }

  static equals(a: Nested_Inner | PlainMessage<Nested_Inner> | undefined, b: Nested_Inner | PlainMessage<Nested_Inner> | undefined): boolean {
    return proto3.util.equals(Nested_Inner, a, b);
  }
}

