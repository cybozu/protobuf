package main

import (
	"fmt"

	"github.com/cybozu/protobuf/cybozu/validate"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

type reInfo struct {
	field *protogen.Field
	reStr string
}

type errorInfo struct {
	name string
	msg  string
}

type Renderer struct {
	me      string
	gen     *protogen.GeneratedFile
	regexps []reInfo
	errors  []errorInfo
}

func NewRenderer(me string, gen *protogen.GeneratedFile) *Renderer {
	return &Renderer{
		me:  me,
		gen: gen,
	}
}

func (r *Renderer) addRegexp(f *protogen.Field, reStr string) {
	r.regexps = append(r.regexps, reInfo{field: f, reStr: reStr})
}

func (r *Renderer) addError(f *protogen.Field, errNamePrefix string, msg string) errorInfo {
	ei := errorInfo{name: errNamePrefix + "_" + f.GoIdent.GoName, msg: msg}
	r.errors = append(r.errors, ei)
	return ei
}

// P appends the arguments to the internal buffer without a newline at the end.
// The arguments are converted to strings as follows:
//
// - If the argument is an `protogen.GoIdent`, this calls `r.gen.QualifiedGoIdent` and append the result string.
// - Other arguments are converted to strings in the same way as `fmt.Print` does.
func (r *Renderer) P(a ...any) {
	for _, t := range a {
		if ident, ok := t.(protogen.GoIdent); ok {
			fmt.Fprint(r.gen, r.gen.QualifiedGoIdent(ident))
			continue
		}
		fmt.Fprint(r.gen, t)
	}
}

// F calls `fmt.Sprintf` with arguments and appends the result to the internal buffer without a newline at the end.
// If an argument is an `protogen.GoIdent`, this calls `r.gen.QualifiedGoIdent` to make it a string
// before passing it to `fmt.Sprintf`
func (r *Renderer) F(format string, a ...any) {
	args := make([]any, len(a))
	for i, t := range a {
		if ident, ok := t.(protogen.GoIdent); ok {
			args[i] = r.gen.QualifiedGoIdent(ident)
			continue
		}
		args[i] = t
	}
	fmt.Fprintf(r.gen, format, args...)
}

// PL appends the arguments to the internal buffer with a newline.
// The arguments are converted to strings as follows:
//
// - If the argument is an `protogen.GoIdent`, this calls `r.gen.QualifiedGoIdent` and append the result string.
// - Other arguments are converted to strings in the same way as `fmt.Print` does.
func (r *Renderer) PL(a ...any) {
	r.gen.P(a...)
}

// FL calls `fmt.Sprintf` with arguments and appends the result to the internal buffer with a newline.
// If an argument is an `protogen.GoIdent`, this calls `r.gen.QualifiedGoIdent` to make it a string
// before passing it to `fmt.Sprintf`
func (r *Renderer) FL(format string, a ...any) {
	args := make([]any, len(a))
	for i, t := range a {
		if ident, ok := t.(protogen.GoIdent); ok {
			args[i] = r.gen.QualifiedGoIdent(ident)
			continue
		}
		args[i] = t
	}
	fmt.Fprintf(r.gen, format, args...)
	r.gen.P()
}

// L appends a newline to the internal buffer.
func (r *Renderer) L() {
	r.gen.P()
}

// Execute renders the file contents.
func (r *Renderer) Execute(pkg protogen.GoPackageName, msgs []*protogen.Message) error {
	r.FL(`// Code generated by %s. DO NOT EDIT.`, r.me)
	r.PL("package ", pkg)

	for _, m := range msgs {
		if err := r.renderMessage(m); err != nil {
			r.gen.Skip()
			return err
		}
	}

	if len(r.regexps) > 0 {
		r.L()
		r.PL(`var (`)
		for _, ri := range r.regexps {
			r.FL(`regex_%s = %s(%q)`, ri.field.GoIdent.GoName, identRegexpMustCompile, ri.reStr)
		}
		r.PL(`)`)
	}

	if len(r.errors) > 0 {
		r.L()
		r.PL(`var (`)
		for _, ei := range r.errors {
			r.FL(`Err%s = %s(%q)`, ei.name, identErrorsNew, ei.msg)
		}
		r.PL(`)`)
	}

	return nil
}

func (r *Renderer) renderMessage(m *protogen.Message) error {
	md := m.Desc
	if md.IsMapEntry() {
		return nil
	}
	ignored := proto.GetExtension(md.Options(), validate.E_Ignored).(bool)
	if ignored {
		return nil
	}

	r.L()
	r.FL(`func (x *%s) Validate() error {`, m.GoIdent.GoName)
	r.PL(`var el []error`)
	for _, f := range m.Fields {
		if err := r.renderField(f, false); err != nil {
			return err
		}
	}
	for _, o := range m.Oneofs {
		if o.Desc.IsSynthetic() {
			// oneof for proto3 option support
			continue
		}
		if err := r.renderOneof(o); err != nil {
			return err
		}
	}
	r.L()
	r.FL(`if err := %s(x); err != nil {`, identCallValidateCustom)
	r.PL(`if v, ok := err.(interface{ Unwrap() []error }); ok {`)
	r.PL(`el = append(el, v.Unwrap()...)`)
	r.PL(`} else {`)
	r.PL(`el = append(el, err)`)
	r.PL(`}`)
	r.PL(`}`)
	r.L()
	r.PL(`if len(el) == 0 {`)
	r.PL(`return nil`)
	r.PL(`}`)
	r.FL(`return %s(el...)`, identErrorsJoin)
	r.PL(`}`)

	for _, inner := range m.Messages {
		if err := r.renderMessage(inner); err != nil {
			return err
		}
	}
	return nil
}

func (r *Renderer) renderOneof(o *protogen.Oneof) error {
	od := o.Desc
	required := proto.GetExtension(o.Desc.Options(), validate.E_Required).(bool)
	if required {
		ei := errorInfo{
			name: "OneOfRequired_" + o.GoIdent.GoName,
			msg:  fmt.Sprintf("one of the fields is required in %s of %s", od.Name(), od.Parent().FullName())}
		r.errors = append(r.errors, ei)
		r.FL(`if x.%s == nil {`, o.GoName)
		r.FL(`el = append(el, Err%s)`, ei.name)
		r.PL(`}`)
	}

	r.FL(`switch x := x.%s.(type) {`, o.GoName)
	for _, f := range o.Fields {
		r.FL(`case *%s:`, f.GoIdent) // here, f.GoIdent represents the Go type for this oneof field.
		r.renderField(f, true)
	}
	r.PL(`default:`)
	r.PL(`_ = x`)
	r.PL(`}`)

	return nil
}
